<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ù…Ù†ØµØ© ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ â€” Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù†Ø©</title>

  <!-- Ø®Ø· Ø¹Ø±Ø¶ (CSS ÙÙ‚Ø· Ù„Ù„Ù€ UI) -->
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#071029; --card:#0f1b2a; --accent:#06b6d4; --muted:#9fb0c9; --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    body{font-family:"Cairo",system-ui,Arial; background:linear-gradient(180deg,#021027 0%,#08172a 100%); color:#e6eef8; margin:0; padding:28px;}
    h1{font-size:20px;text-align:center;color:var(--accent);margin-bottom:10px}
    .wrap{max-width:1100px;margin:0 auto}
    .top{display:flex;gap:16px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(3,8,20,.6);border:1px solid var(--glass)}
    textarea{width:100%;min-height:180px;padding:14px;border-radius:9px;background:#071528;border:1px solid rgba(255,255,255,.03);color:#dff3ff;resize:vertical}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{background:linear-gradient(135deg,#3b82f6,#06b6d4);border:0;padding:10px 12px;border-radius:10px;color:#002;cursor:pointer;font-weight:700}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,.05);color:var(--muted)}
    .cols{display:grid;grid-template-columns:1fr 420px;gap:18px;margin-top:18px}
    .output{margin-top:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,.02)}
    ul{list-style:none;padding:0;margin:0;max-height:420px;overflow:auto}
    ul li{padding:8px;border-bottom:1px solid rgba(255,255,255,.03)}
    .schedule{margin-top:16px;overflow:auto}
    table{width:100%;border-collapse:collapse;background:transparent}
    th,td{padding:10px;border:1px solid rgba(255,255,255,.04);text-align:center;font-size:14px}
    th{background:rgba(6,182,212,.12);color:var(--accent)}
    .note{color:var(--muted);font-size:13px;margin-top:8px}
    @media(max-width:980px){.cols{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <h1>Ù…Ù†ØµØ© ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ â€” Ø£Ø¯Ø§Ø© ÙˆØ§Ø­Ø¯Ø© Ù…ØªÙƒØ§Ù…Ù„Ø©</h1>
      <div class="note">Ø§Ù„ØµÙ‚ Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… â€” Ø§Ù„Ø£Ø¯Ø§Ø© ØªØ­Ø§ÙˆÙ„ Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ² ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙˆØªØ³ØªØ®Ø±Ø¬ Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´ÙØ¹Ø¨ ÙˆØªØµØ¯Ø± Ø§Ù„Ù†ØªØ§Ø¦Ø¬.</div>
    </div>

    <div class="card">
      <label for="inputText" class="note">ğŸ“‹ Ø§Ù„ØµÙ‚ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§ (Ø³Ø·Ø±/Ø¨Ù„ÙˆÙƒ):</label>
      <textarea id="inputText" placeholder="Ù…Ø«Ø§Ù„: ØªØ´Ø±ÙŠØ­ Ø¨ÙŠØ·Ø±ÙŠ (2) - Ø´Ø¹Ø¨Ø© 1 (Ø«Ù„ 9:00**10:00)"></textarea>

      <div class="controls">
        <button id="btnExtract">ğŸ“‘ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…ÙˆØ§Ø¯</button>
        <button id="btnMakeTable">ğŸ“… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„</button>
        <button id="btnTXT">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ TXT</button>
        <button id="btnExcel">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ Excel</button>
        <button id="btnPDF">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ PDF</button>
        <button id="btnClear" class="ghost">Ù…Ø³Ø­ Ø§Ù„Ø­Ù‚Ù„</button>
      </div>

      <div class="cols" style="margin-top:14px">
        <div class="card">
          <h3 style="margin:0 0 8px;color:var(--accent)">ğŸ“Œ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´ÙØ¹Ø¨</h3>
          <div class="output" id="listWrap"><ul id="courseList"></ul></div>
        </div>

        <div class="card">
          <h3 style="margin:0 0 8px;color:var(--accent)">âš™ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¬Ø¯ÙˆÙ„</h3>
          <div class="output schedule" id="scheduleContainer">
            <div class="note">Ø§Ø¶ØºØ· "Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„" Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‡Ù†Ø§.</div>
          </div>
        </div>
      </div>
    </div>

    <p class="note" style="text-align:center;margin-top:12px">ØªÙ… ØªØ·ÙˆÙŠØ±Ù‡Ø§ Ø¨Ù€Ù€ HTML/CSS/JS ÙÙ‚Ø· â€” ØªØ¯Ø¹Ù… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø§Ù„Ø¹Ø±Ø¨ÙŠ ÙˆØªØµØ¯ÙŠØ± PDF (ØµÙˆØ±Ø©) Ù„Ø­Ù„ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªØ´ÙƒÙŠÙ„ ÙˆØ§Ù„Ø®Ø·ÙˆØ·.</p>
  </div>

  <!-- Ù…ÙƒØªØ¨Ø§Øª -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
  /**************************************************************************
   * Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù‘Ù†Ø© â€” Ø¥ØµÙ„Ø§Ø­ ØªØ±Ù…ÙŠØ² Ø§Ù„Ù†Øµ (mojibake) + Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ØªÙƒØ§Ù…Ù„ + ØªØµØ¯ÙŠØ±
   * ÙÙƒØ±Ø© Ù…Ù‡Ù…Ø©: Ù„ØªØ­Ù…ÙŠÙ„ PDF Ù†Ø³ØªØ®Ø¯Ù… html2canvas â†’ ØµÙˆØ±Ø© â†’ jsPDF
   * Ù‡Ø°Ø§ ÙŠØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ ØªØ´ÙƒÙŠÙ„ Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¯Ø§Ø®Ù„ jsPDF Ù†ÙØ³Ù‡.
   **************************************************************************/

  let extractedData = [];

  // 1) Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø¥Ù† Ù„Ø²Ù…
  function fixEncoding(str) {
    if (!str || typeof str !== 'string') return str;
    // Try a safe conversion. Only use converted version if it produces Arabic letters
    try {
      const converted = decodeURIComponent(escape(str));
      const hasArabicOrig = /[\u0600-\u06FF]/.test(str);
      const hasArabicConv = /[\u0600-\u06FF]/.test(converted);
      // If conversion yields Arabic when original doesn't â€” use it.
      if (hasArabicConv && !hasArabicOrig) return converted;
      return str;
    } catch (e) {
      return str;
    }
  }

  // 2) Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø·Ø±
  function normalizeLine(s) {
    return s.replace(/\u00A0/g,' ').replace(/\t+/g,' ').replace(/\s+/g,' ').trim();
  }

  // 3) Ø¯Ø§Ù„Ø© ØªØ­Ù„ÙŠÙ„ Ø³Ø·Ø± ÙˆØ§Ø­Ø¯ â€” ØªØ¯Ø¹Ù… Ø£Ù†Ù…Ø§Ø· Ù…ØªØ¹Ø¯Ø¯Ø©
  function parseCourseLine(line) {
    line = normalizeLine(line);
    if (!line) return null;

    // Attempt: split by dash (first dash) to separate course name and details
    let coursePart = line;
    let rest = '';
    const dashMatch = line.match(/[-â€“â€”]/);
    if (dashMatch) {
      const idx = line.indexOf(dashMatch[0]);
      coursePart = line.slice(0, idx).trim();
      rest = line.slice(idx + 1).trim();
    }

    // If pattern "Ø§Ø³Ù… - Ø´Ø¹Ø¨Ø© X (day time**time)" common:
    // extract section (Ø´Ø¹Ø¨Ø©)
    let section = '';
    const sec1 = rest.match(/Ø´Ø¹Ø¨Ø©\s*([^\s()]+)/i) || coursePart.match(/Ø´Ø¹Ø¨Ø©\s*([^\s()]+)/i);
    if (sec1) section = sec1[1].trim();

    // extract parentheses content (likely day/time)
    let day = '', time = '', room = '';
    let paren = (rest.match(/\(([^)]+)\)/) || coursePart.match(/\(([^)]+)\)/));
    if (paren) {
      const inside = paren[1];
      // time pattern like 9:00**11:30 (with ** or maybe - or to)
      const timeMatch = inside.match(/(\d{1,2}:\d{2})\s*\*{2}\s*(\d{1,2}:\d{2})/) ||
                        inside.match(/(\d{1,2}:\d{2})\s*[-â€“to]{1,3}\s*(\d{1,2}:\d{2})/i);
      if (timeMatch) time = `${timeMatch[1]} - ${timeMatch[2]}`;

      // day detection (short forms used in your data)
      const dayMatch = inside.match(/\b(Ø­Ø¯|Ø£Ø­Ø¯|Ø§Ù„Ø§Ø­Ø¯|Ø«Ù†|Ø§Ø«Ù†ÙŠÙ†|Ø«Ù„|Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡|Ø±Ø¨Ø¹|Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡|Ø®Ù…ÙŠØ³|Ø§Ù„Ø¬Ù…Ø¹Ø©|Ø³Ø¨Øª|Ø§Ù„Ø³Ø¨Øª)\b/i);
      if (dayMatch) day = dayMatch[1];

      // room: words like NB53, SF07, LAB, U, SG17, SF06 etc
      const roomMatch = inside.match(/\b(NB\d+|SF\d+|SG\d+|LAB|U|[A-Z]{2,}\d{0,})\b/i);
      if (roomMatch) room = roomMatch[1];
    } else {
      // fallback: try to find time/day/room in rest without parentheses
      const timeMatch = rest.match(/(\d{1,2}:\d{2})\s*\*{2}\s*(\d{1,2}:\d{2})/) ||
                        rest.match(/(\d{1,2}:\d{2})\s*[-â€“to]{1,3}\s*(\d{1,2}:\d{2})/i);
      if (timeMatch) time = `${timeMatch[1]} - ${timeMatch[2]}`;
      const dayMatch = rest.match(/\b(Ø­Ø¯|Ø£Ø­Ø¯|Ø§Ù„Ø§Ø­Ø¯|Ø«Ù†|Ø§Ø«Ù†ÙŠÙ†|Ø«Ù„|Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡|Ø±Ø¨Ø¹|Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡|Ø®Ù…ÙŠØ³|Ø§Ù„Ø¬Ù…Ø¹Ø©|Ø³Ø¨Øª|Ø§Ù„Ø³Ø¨Øª)\b/i);
      if (dayMatch) day = dayMatch[1];
      const roomMatch = rest.match(/\b(NB\d+|SF\d+|SG\d+|LAB|U|[A-Z]{2,}\d{0,})\b/i);
      if (roomMatch) room = roomMatch[1];
    }

    // final cleanup of course name: remove trailing 'Ø´Ø¹Ø¨Ø© ...' in case included
    let course = coursePart.replace(/\bØ´Ø¹Ø¨Ø©\b.*$/i,'').trim();
    if (!course && rest) {
      // sometimes course is on the right side
      course = rest.replace(/\bØ´Ø¹Ø¨Ø©\b.*$/i,'').trim();
    }

    if (!course) return null;
    return { course, section, day, time, room, raw: line };
  }

  // 4) Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ â€” ØªØ¯Ø¹Ù… Ø¨Ù„ÙˆÙƒØ§Øª Ø¨ØªÙ†Ø³ÙŠÙ‚ "Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚:" Ùˆ ÙƒØ°Ù„Ùƒ Ø³Ø·ÙˆØ± Ù…ÙØ±Ø¯Ø©
  function extractCourses() {
    const raw = document.getElementById('inputText').value || '';
    const fixed = fixEncoding(raw);
    const lines = fixed.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

    extractedData = [];

    const fullText = lines.join('\n');

    // Case A: block-style input containing "Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚" => parse blocks
    if (/Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(fullText) || /Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(fullText)) {
      // split into blocks by "Ø±Ù‚Ù… Ø§Ù„Ø³Ø·Ø±" or "Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚" or blank lines
      const blocks = fullText.split(/\r?\n(?=Ø±Ù‚Ù… Ø§Ù„Ø³Ø·Ø±:|Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚:|Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚:)/i);
      for (const block of blocks) {
        const bLines = block.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
        // find course name
        const nameLine = bLines.find(l => /Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(l));
        const courseName = nameLine ? (nameLine.split(':').slice(1).join(':').trim()) : '';
        // find data table lines (lines that start with a digit or look like "1  Ø«Ù„ 9:00**10:00 NB53")
        for (const l of bLines) {
          if (/^\d+\s/.test(l) || /^\d+\t/.test(l) || /\d+\s+[^\s]+\s+\d{1,2}:\d{2}/.test(l)) {
            // split by tabs or multiple spaces
            const parts = l.split(/\t+/).map(p => p.trim()).filter(Boolean);
            // if tab-style (columns) we expect: index, day, time, room, ... or index, day, time, room, etc.
            if (parts.length >= 3) {
              // try map columns intelligently
              // sample patterns from your data: "1\tØ«Ù„\t9:00**10:00\tNB53\t\t\t194\t194\t150\t...Ø§Ù„Ù…Ø¯Ø±Ø³..."
              // We'll take parts[1] as day, parts[2] as time, parts[3] as room if exists; section might be not present in these rows
              const idx = parts[0];
              let section = ''; // sometimes not in column
              let day = parts[1] || '';
              let time = parts[2] ? parts[2].replace(/\s*\*\*\s*/g,' - ').trim() : '';
              let room = parts[3] || '';
              extractedData.push({
                course: courseName || '',
                section: section,
                day: day,
                time: time,
                room: room,
                raw: l
              });
            } else {
              // try parse the whole line with general parser
              const parsed = parseCourseLine(l);
              if (parsed) {
                // if courseName exists and parsed.course is small (like contains 'Ø´Ø¹Ø¨Ø©'), prefer courseName
                if (courseName && (!parsed.course || parsed.course.length < 3)) parsed.course = courseName;
                extractedData.push(parsed);
              }
            }
          }
        }
      }
    } else {
      // Case B: line-by-line parse (each line describes one entry)
      for (const line of lines) {
        const parsed = parseCourseLine(line);
        if (parsed) extractedData.push(parsed);
      }
    }

    // post-process: if some entries lack course but there are previous course names in data, keep them
    // also remove duplicates (same course/section/day/time)
    const seen = new Set();
    extractedData = extractedData.filter(e => {
      const key = `${e.course}|${e.section}|${e.day}|${e.time}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });

    renderCourseList();
    alert(`ØªÙ… Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ â€” ${extractedData.length} Ø³Ø·Ø±/Ø­Ø¯Ø« Ù…Ø³ØªØ®Ø±Ø¬`);
  }

  // 5) Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
  function renderCourseList() {
    const ul = document.getElementById('courseList');
    ul.innerHTML = '';
    if (extractedData.length === 0) {
      ul.innerHTML = '<li class="note">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³ØªØ®Ø±Ø¬Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†.</li>';
      return;
    }
    extractedData.forEach((d,i) => {
      const li = document.createElement('li');
      li.textContent = `${i+1}. ${d.course || '-'} ${d.section ? 'â€” Ø´Ø¹Ø¨Ø© ' + d.section : ''} ${d.day ? ' | ' + d.day : ''} ${d.time ? ' | ' + d.time : ''} ${d.room ? ' | ' + d.room : ''}`;
      ul.appendChild(li);
    });
  }

  // 6) Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø¹Ø±Ø¶ Ø¨Ø³ÙŠØ· (Ù‚Ø§Ø¦Ù…Ø© Ù…Ø±ØªØ¨Ø© Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…)
  function generateSchedule() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£ÙŠ Ù…ÙˆØ§Ø¯ Ø¨Ø¹Ø¯!');
    const dayOrder = ['Ø­Ø¯','Ø£Ø­Ø¯','Ø§Ù„Ø§Ù„Ø§Ø­Ø¯','Ø§Ù„Ø§Ø­Ø¯','Ø«Ù†','Ø§Ø«Ù†ÙŠÙ†','Ø«Ù„','Ø±Ø¨Ø¹','Ø§Ù„Ø®Ù…ÙŠØ³','Ø®Ù…ÙŠØ³','Ø§Ù„Ø¬Ù…Ø¹Ø©','Ø³Ø¨Øª','Ø§Ù„Ø³Ø¨Øª'];
    const dayMap = { 'Ø§Ù„Ø³Ø¨Øª':'Ø§Ù„Ø³Ø¨Øª','Ø³Ø¨Øª':'Ø§Ù„Ø³Ø¨Øª','Ø§Ù„Ø£Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø§Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø«Ù†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ø«Ù†ÙŠÙ†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ù„Ø§Ø«Ù†ÙŠÙ†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø«Ù„':'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡':'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø±Ø¨Ø¹':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø®Ù…ÙŠØ³':'Ø§Ù„Ø®Ù…ÙŠØ³','Ø¬Ù…Ø¹Ø©':'Ø§Ù„Ø¬Ù…Ø¹Ø©','Ø§Ù„Ø¬Ù…Ø¹Ø©':'Ø§Ù„Ø¬Ù…Ø¹Ø©' };

    // group by day (keep original order if day unknown)
    const grouped = {};
    for (const e of extractedData) {
      let dayKey = e.day || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
      // normalize simple forms
      if (dayMap[e.day]) dayKey = dayMap[e.day];
      if (!grouped[dayKey]) grouped[dayKey] = [];
      grouped[dayKey].push(e);
    }

    // build HTML table
    let html = '<table><thead><tr><th>#</th><th>Ø§Ù„ÙŠÙˆÙ…</th><th>Ø§Ù„Ù…Ù‚Ø±Ø±</th><th>Ø§Ù„Ø´Ø¹Ø¨Ø©</th><th>Ø§Ù„ÙˆÙ‚Øª</th><th>Ø§Ù„Ù‚Ø§Ø¹Ø©</th></tr></thead><tbody>';
    let idx = 1;
    // sort keys by dayOrder preference
    const keys = Object.keys(grouped);
    keys.sort((a,b) => {
      const ia = dayOrder.findIndex(x => a.includes(x)) === -1 ? 999 : dayOrder.findIndex(x => a.includes(x));
      const ib = dayOrder.findIndex(x => b.includes(x)) === -1 ? 999 : dayOrder.findIndex(x => b.includes(x));
      return ia - ib;
    });
    for (const k of keys) {
      for (const row of grouped[k]) {
        html += `<tr>
                   <td>${idx++}</td>
                   <td>${k}</td>
                   <td>${escapeHtml(row.course || '-')}</td>
                   <td>${escapeHtml(row.section || '-')}</td>
                   <td>${escapeHtml(row.time || '-')}</td>
                   <td>${escapeHtml(row.room || '-')}</td>
                 </tr>`;
      }
    }
    html += '</tbody></table>';
    document.getElementById('scheduleContainer').innerHTML = html;
  }

  // 7) ØªØ­Ù…ÙŠÙ„ TXT â€” Ù†Ø¶ÙŠÙ BOM Ø¹Ø´Ø§Ù† ÙŠÙØªØ­ Ø¹Ø±Ø¨ÙŠ Ù…Ø¸Ø¨ÙˆØ· ÙÙŠ Ø¨Ø±Ø§Ù…Ø¬ ÙˆÙŠÙ†Ø¯ÙˆØ²
  function downloadTXT() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!');
    const lines = extractedData.map(d => `${d.course} - Ø´Ø¹Ø¨Ø© ${d.section || '-'} | ${d.day || '-'} | ${d.time || '-'} | ${d.room || '-'}`);
    const content = '\uFEFF' + lines.join('\n'); // BOM
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'courses.txt';
    document.body.appendChild(a); a.click(); a.remove();
  }

  // 8) ØªØ­Ù…ÙŠÙ„ Excel (xlsx) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… SheetJS
  function downloadExcel() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!');
    const aoa = [
      ['Ø§Ù„Ù…Ù‚Ø±Ø±','Ø§Ù„Ø´Ø¹Ø¨Ø©','Ø§Ù„ÙŠÙˆÙ…','Ø§Ù„ÙˆÙ‚Øª','Ø§Ù„Ù‚Ø§Ø¹Ø©']
    ];
    extractedData.forEach(d => {
      aoa.push([d.course || '', d.section || '', d.day || '', d.time || '', d.room || '']);
    });
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯');
    XLSX.writeFile(wb, 'courses.xlsx');
  }

  // 9) ØªØ­Ù…ÙŠÙ„ PDF â€” Ù†Ù„ØªÙ‚Ø· Ø¹Ù†ØµØ± Ø§Ù„Ù€ .wrap (ÙŠØ¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ùˆ Ø§Ù„Ø¬Ø¯ÙˆÙ„) ÙƒØµÙˆØ±Ø© Ø«Ù… Ù†Ø¶ÙŠÙÙ‡Ø§ Ø¥Ù„Ù‰ PDF
  async function downloadPDF() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!');

    const el = document.querySelector('.wrap');
    // Ø²ÙŠØ§Ø¯Ø© scale Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¬ÙˆØ¯Ø©
    const canvas = await html2canvas(el, { scale: 2, useCORS: true, backgroundColor: null });
    const imgData = canvas.toDataURL('image/png');

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p','pt','a4');
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();

    const imgWidth = pdfWidth;
    const imgHeight = (canvas.height * imgWidth) / canvas.width;

    let heightLeft = imgHeight;
    let position = 0;

    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pdfHeight;

    while (heightLeft > 0) {
      position -= pdfHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pdfHeight;
    }

    pdf.save('courses.pdf');
  }

  // Utility: escapeHtml (to render raw strings safely)
  function escapeHtml(s) {
    if (!s) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Buttons wiring
  document.getElementById('btnExtract').addEventListener('click', () => {
    try { extractCourses(); }
    catch (e) { console.error(e); alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬Ø› ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù†Øµ Ø£Ùˆ Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ø«Ø§Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ³ØªØ®Ø¯Ù…Ù‡.'); }
  });
  document.getElementById('btnMakeTable').addEventListener('click', () => {
    try { generateSchedule(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„'); }
  });
  document.getElementById('btnTXT').addEventListener('click', () => {
    try { downloadTXT(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ TXT'); }
  });
  document.getElementById('btnExcel').addEventListener('click', () => {
    try { downloadExcel(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Excel'); }
  });
  document.getElementById('btnPDF').addEventListener('click', () => {
    try { downloadPDF(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ PDF'); }
  });
  document.getElementById('btnClear').addEventListener('click', () => {
    document.getElementById('inputText').value = '';
    extractedData = [];
    renderCourseList();
    document.getElementById('scheduleContainer').innerHTML = '<div class="note">Ø§Ø¶ØºØ· "Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„" Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‡Ù†Ø§.</div>';
  });

  // Ø¨Ø¯Ø§ÙŠØ©: Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
  renderCourseList();

  </script>

</body>
</html>        <div class="card">
          <h3 style="margin:0 0 8px;color:var(--accent)">ğŸ“Œ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´ÙØ¹Ø¨</h3>
          <div class="output" id="listWrap"><ul id="courseList"></ul></div>
        </div>

        <div class="card">
          <h3 style="margin:0 0 8px;color:var(--accent)">âš™ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¬Ø¯ÙˆÙ„</h3>
          <div class="output schedule" id="scheduleContainer">
            <div class="note">Ø§Ø¶ØºØ· "Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„" Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‡Ù†Ø§.</div>
          </div>
        </div>
      </div>
    </div>

    <p class="note" style="text-align:center;margin-top:12px">ØªÙ… ØªØ·ÙˆÙŠØ±Ù‡Ø§ Ø¨Ù€Ù€ HTML/CSS/JS ÙÙ‚Ø· â€” ØªØ¯Ø¹Ù… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø§Ù„Ø¹Ø±Ø¨ÙŠ ÙˆØªØµØ¯ÙŠØ± PDF (ØµÙˆØ±Ø©) Ù„Ø­Ù„ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªØ´ÙƒÙŠÙ„ ÙˆØ§Ù„Ø®Ø·ÙˆØ·.</p>
  </div>

  <!-- Ù…ÙƒØªØ¨Ø§Øª -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
  /**************************************************************************
   * Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù‘Ù†Ø© â€” Ø¥ØµÙ„Ø§Ø­ ØªØ±Ù…ÙŠØ² Ø§Ù„Ù†Øµ (mojibake) + Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ØªÙƒØ§Ù…Ù„ + ØªØµØ¯ÙŠØ±
   * ÙÙƒØ±Ø© Ù…Ù‡Ù…Ø©: Ù„ØªØ­Ù…ÙŠÙ„ PDF Ù†Ø³ØªØ®Ø¯Ù… html2canvas â†’ ØµÙˆØ±Ø© â†’ jsPDF
   * Ù‡Ø°Ø§ ÙŠØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ ØªØ´ÙƒÙŠÙ„ Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¯Ø§Ø®Ù„ jsPDF Ù†ÙØ³Ù‡.
   **************************************************************************/

  let extractedData = [];

  // 1) Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø¥Ù† Ù„Ø²Ù…
  function fixEncoding(str) {
    if (!str || typeof str !== 'string') return str;
    // Try a safe conversion. Only use converted version if it produces Arabic letters
    try {
      const converted = decodeURIComponent(escape(str));
      const hasArabicOrig = /[\u0600-\u06FF]/.test(str);
      const hasArabicConv = /[\u0600-\u06FF]/.test(converted);
      // If conversion yields Arabic when original doesn't â€” use it.
      if (hasArabicConv && !hasArabicOrig) return converted;
      return str;
    } catch (e) {
      return str;
    }
  }

  // 2) Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø·Ø±
  function normalizeLine(s) {
    return s.replace(/\u00A0/g,' ').replace(/\t+/g,' ').replace(/\s+/g,' ').trim();
  }

  // 3) Ø¯Ø§Ù„Ø© ØªØ­Ù„ÙŠÙ„ Ø³Ø·Ø± ÙˆØ§Ø­Ø¯ â€” ØªØ¯Ø¹Ù… Ø£Ù†Ù…Ø§Ø· Ù…ØªØ¹Ø¯Ø¯Ø©
  function parseCourseLine(line) {
    line = normalizeLine(line);
    if (!line) return null;

    // Attempt: split by dash (first dash) to separate course name and details
    let coursePart = line;
    let rest = '';
    const dashMatch = line.match(/[-â€“â€”]/);
    if (dashMatch) {
      const idx = line.indexOf(dashMatch[0]);
      coursePart = line.slice(0, idx).trim();
      rest = line.slice(idx + 1).trim();
    }

    // If pattern "Ø§Ø³Ù… - Ø´Ø¹Ø¨Ø© X (day time**time)" common:
    // extract section (Ø´Ø¹Ø¨Ø©)
    let section = '';
    const sec1 = rest.match(/Ø´Ø¹Ø¨Ø©\s*([^\s()]+)/i) || coursePart.match(/Ø´Ø¹Ø¨Ø©\s*([^\s()]+)/i);
    if (sec1) section = sec1[1].trim();

    // extract parentheses content (likely day/time)
    let day = '', time = '', room = '';
    let paren = (rest.match(/\(([^)]+)\)/) || coursePart.match(/\(([^)]+)\)/));
    if (paren) {
      const inside = paren[1];
      // time pattern like 9:00**11:30 (with ** or maybe - or to)
      const timeMatch = inside.match(/(\d{1,2}:\d{2})\s*\*{2}\s*(\d{1,2}:\d{2})/) ||
                        inside.match(/(\d{1,2}:\d{2})\s*[-â€“to]{1,3}\s*(\d{1,2}:\d{2})/i);
      if (timeMatch) time = `${timeMatch[1]} - ${timeMatch[2]}`;

      // day detection (short forms used in your data)
      const dayMatch = inside.match(/\b(Ø­Ø¯|Ø£Ø­Ø¯|Ø§Ù„Ø§Ø­Ø¯|Ø«Ù†|Ø§Ø«Ù†ÙŠÙ†|Ø«Ù„|Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡|Ø±Ø¨Ø¹|Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡|Ø®Ù…ÙŠØ³|Ø§Ù„Ø¬Ù…Ø¹Ø©|Ø³Ø¨Øª|Ø§Ù„Ø³Ø¨Øª)\b/i);
      if (dayMatch) day = dayMatch[1];

      // room: words like NB53, SF07, LAB, U, SG17, SF06 etc
      const roomMatch = inside.match(/\b(NB\d+|SF\d+|SG\d+|LAB|U|[A-Z]{2,}\d{0,})\b/i);
      if (roomMatch) room = roomMatch[1];
    } else {
      // fallback: try to find time/day/room in rest without parentheses
      const timeMatch = rest.match(/(\d{1,2}:\d{2})\s*\*{2}\s*(\d{1,2}:\d{2})/) ||
                        rest.match(/(\d{1,2}:\d{2})\s*[-â€“to]{1,3}\s*(\d{1,2}:\d{2})/i);
      if (timeMatch) time = `${timeMatch[1]} - ${timeMatch[2]}`;
      const dayMatch = rest.match(/\b(Ø­Ø¯|Ø£Ø­Ø¯|Ø§Ù„Ø§Ø­Ø¯|Ø«Ù†|Ø§Ø«Ù†ÙŠÙ†|Ø«Ù„|Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡|Ø±Ø¨Ø¹|Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡|Ø®Ù…ÙŠØ³|Ø§Ù„Ø¬Ù…Ø¹Ø©|Ø³Ø¨Øª|Ø§Ù„Ø³Ø¨Øª)\b/i);
      if (dayMatch) day = dayMatch[1];
      const roomMatch = rest.match(/\b(NB\d+|SF\d+|SG\d+|LAB|U|[A-Z]{2,}\d{0,})\b/i);
      if (roomMatch) room = roomMatch[1];
    }

    // final cleanup of course name: remove trailing 'Ø´Ø¹Ø¨Ø© ...' in case included
    let course = coursePart.replace(/\bØ´Ø¹Ø¨Ø©\b.*$/i,'').trim();
    if (!course && rest) {
      // sometimes course is on the right side
      course = rest.replace(/\bØ´Ø¹Ø¨Ø©\b.*$/i,'').trim();
    }

    if (!course) return null;
    return { course, section, day, time, room, raw: line };
  }

  // 4) Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ â€” ØªØ¯Ø¹Ù… Ø¨Ù„ÙˆÙƒØ§Øª Ø¨ØªÙ†Ø³ÙŠÙ‚ "Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚:" Ùˆ ÙƒØ°Ù„Ùƒ Ø³Ø·ÙˆØ± Ù…ÙØ±Ø¯Ø©
  function extractCourses() {
    const raw = document.getElementById('inputText').value || '';
    const fixed = fixEncoding(raw);
    const lines = fixed.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

    extractedData = [];

    const fullText = lines.join('\n');

    // Case A: block-style input containing "Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚" => parse blocks
    if (/Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(fullText) || /Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(fullText)) {
      // split into blocks by "Ø±Ù‚Ù… Ø§Ù„Ø³Ø·Ø±" or "Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚" or blank lines
      const blocks = fullText.split(/\r?\n(?=Ø±Ù‚Ù… Ø§Ù„Ø³Ø·Ø±:|Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚:|Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚:)/i);
      for (const block of blocks) {
        const bLines = block.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
        // find course name
        const nameLine = bLines.find(l => /Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(l));
        const courseName = nameLine ? (nameLine.split(':').slice(1).join(':').trim()) : '';
        // find data table lines (lines that start with a digit or look like "1  Ø«Ù„ 9:00**10:00 NB53")
        for (const l of bLines) {
          if (/^\d+\s/.test(l) || /^\d+\t/.test(l) || /\d+\s+[^\s]+\s+\d{1,2}:\d{2}/.test(l)) {
            // split by tabs or multiple spaces
            const parts = l.split(/\t+/).map(p => p.trim()).filter(Boolean);
            // if tab-style (columns) we expect: index, day, time, room, ... or index, day, time, room, etc.
            if (parts.length >= 3) {
              // try map columns intelligently
              // sample patterns from your data: "1\tØ«Ù„\t9:00**10:00\tNB53\t\t\t194\t194\t150\t...Ø§Ù„Ù…Ø¯Ø±Ø³..."
              // We'll take parts[1] as day, parts[2] as time, parts[3] as room if exists; section might be not present in these rows
              const idx = parts[0];
              let section = ''; // sometimes not in column
              let day = parts[1] || '';
              let time = parts[2] ? parts[2].replace(/\s*\*\*\s*/g,' - ').trim() : '';
              let room = parts[3] || '';
              extractedData.push({
                course: courseName || '',
                section: section,
                day: day,
                time: time,
                room: room,
                raw: l
              });
            } else {
              // try parse the whole line with general parser
              const parsed = parseCourseLine(l);
              if (parsed) {
                // if courseName exists and parsed.course is small (like contains 'Ø´Ø¹Ø¨Ø©'), prefer courseName
                if (courseName && (!parsed.course || parsed.course.length < 3)) parsed.course = courseName;
                extractedData.push(parsed);
              }
            }
          }
        }
      }
    } else {
      // Case B: line-by-line parse (each line describes one entry)
      for (const line of lines) {
        const parsed = parseCourseLine(line);
        if (parsed) extractedData.push(parsed);
      }
    }

    // post-process: if some entries lack course but there are previous course names in data, keep them
    // also remove duplicates (same course/section/day/time)
    const seen = new Set();
    extractedData = extractedData.filter(e => {
      const key = `${e.course}|${e.section}|${e.day}|${e.time}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });

    renderCourseList();
    alert(`ØªÙ… Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ â€” ${extractedData.length} Ø³Ø·Ø±/Ø­Ø¯Ø« Ù…Ø³ØªØ®Ø±Ø¬`);
  }

  // 5) Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
  function renderCourseList() {
    const ul = document.getElementById('courseList');
    ul.innerHTML = '';
    if (extractedData.length === 0) {
      ul.innerHTML = '<li class="note">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³ØªØ®Ø±Ø¬Ø© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†.</li>';
      return;
    }
    extractedData.forEach((d,i) => {
      const li = document.createElement('li');
      li.textContent = `${i+1}. ${d.course || '-'} ${d.section ? 'â€” Ø´Ø¹Ø¨Ø© ' + d.section : ''} ${d.day ? ' | ' + d.day : ''} ${d.time ? ' | ' + d.time : ''} ${d.room ? ' | ' + d.room : ''}`;
      ul.appendChild(li);
    });
  }

  // 6) Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø¹Ø±Ø¶ Ø¨Ø³ÙŠØ· (Ù‚Ø§Ø¦Ù…Ø© Ù…Ø±ØªØ¨Ø© Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…)
  function generateSchedule() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£ÙŠ Ù…ÙˆØ§Ø¯ Ø¨Ø¹Ø¯!');
    const dayOrder = ['Ø­Ø¯','Ø£Ø­Ø¯','Ø§Ù„Ø§Ù„Ø§Ø­Ø¯','Ø§Ù„Ø§Ø­Ø¯','Ø«Ù†','Ø§Ø«Ù†ÙŠÙ†','Ø«Ù„','Ø±Ø¨Ø¹','Ø§Ù„Ø®Ù…ÙŠØ³','Ø®Ù…ÙŠØ³','Ø§Ù„Ø¬Ù…Ø¹Ø©','Ø³Ø¨Øª','Ø§Ù„Ø³Ø¨Øª'];
    const dayMap = { 'Ø§Ù„Ø³Ø¨Øª':'Ø§Ù„Ø³Ø¨Øª','Ø³Ø¨Øª':'Ø§Ù„Ø³Ø¨Øª','Ø§Ù„Ø£Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø§Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø«Ù†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ø«Ù†ÙŠÙ†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ù„Ø§Ø«Ù†ÙŠÙ†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø«Ù„':'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡':'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø±Ø¨Ø¹':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø®Ù…ÙŠØ³':'Ø§Ù„Ø®Ù…ÙŠØ³','Ø¬Ù…Ø¹Ø©':'Ø§Ù„Ø¬Ù…Ø¹Ø©','Ø§Ù„Ø¬Ù…Ø¹Ø©':'Ø§Ù„Ø¬Ù…Ø¹Ø©' };

    // group by day (keep original order if day unknown)
    const grouped = {};
    for (const e of extractedData) {
      let dayKey = e.day || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
      // normalize simple forms
      if (dayMap[e.day]) dayKey = dayMap[e.day];
      if (!grouped[dayKey]) grouped[dayKey] = [];
      grouped[dayKey].push(e);
    }

    // build HTML table
    let html = '<table><thead><tr><th>#</th><th>Ø§Ù„ÙŠÙˆÙ…</th><th>Ø§Ù„Ù…Ù‚Ø±Ø±</th><th>Ø§Ù„Ø´Ø¹Ø¨Ø©</th><th>Ø§Ù„ÙˆÙ‚Øª</th><th>Ø§Ù„Ù‚Ø§Ø¹Ø©</th></tr></thead><tbody>';
    let idx = 1;
    // sort keys by dayOrder preference
    const keys = Object.keys(grouped);
    keys.sort((a,b) => {
      const ia = dayOrder.findIndex(x => a.includes(x)) === -1 ? 999 : dayOrder.findIndex(x => a.includes(x));
      const ib = dayOrder.findIndex(x => b.includes(x)) === -1 ? 999 : dayOrder.findIndex(x => b.includes(x));
      return ia - ib;
    });
    for (const k of keys) {
      for (const row of grouped[k]) {
        html += `<tr>
                   <td>${idx++}</td>
                   <td>${k}</td>
                   <td>${escapeHtml(row.course || '-')}</td>
                   <td>${escapeHtml(row.section || '-')}</td>
                   <td>${escapeHtml(row.time || '-')}</td>
                   <td>${escapeHtml(row.room || '-')}</td>
                 </tr>`;
      }
    }
    html += '</tbody></table>';
    document.getElementById('scheduleContainer').innerHTML = html;
  }

  // 7) ØªØ­Ù…ÙŠÙ„ TXT â€” Ù†Ø¶ÙŠÙ BOM Ø¹Ø´Ø§Ù† ÙŠÙØªØ­ Ø¹Ø±Ø¨ÙŠ Ù…Ø¸Ø¨ÙˆØ· ÙÙŠ Ø¨Ø±Ø§Ù…Ø¬ ÙˆÙŠÙ†Ø¯ÙˆØ²
  function downloadTXT() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!');
    const lines = extractedData.map(d => `${d.course} - Ø´Ø¹Ø¨Ø© ${d.section || '-'} | ${d.day || '-'} | ${d.time || '-'} | ${d.room || '-'}`);
    const content = '\uFEFF' + lines.join('\n'); // BOM
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'courses.txt';
    document.body.appendChild(a); a.click(); a.remove();
  }

  // 8) ØªØ­Ù…ÙŠÙ„ Excel (xlsx) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… SheetJS
  function downloadExcel() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!');
    const aoa = [
      ['Ø§Ù„Ù…Ù‚Ø±Ø±','Ø§Ù„Ø´Ø¹Ø¨Ø©','Ø§Ù„ÙŠÙˆÙ…','Ø§Ù„ÙˆÙ‚Øª','Ø§Ù„Ù‚Ø§Ø¹Ø©']
    ];
    extractedData.forEach(d => {
      aoa.push([d.course || '', d.section || '', d.day || '', d.time || '', d.room || '']);
    });
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯');
    XLSX.writeFile(wb, 'courses.xlsx');
  }

  // 9) ØªØ­Ù…ÙŠÙ„ PDF â€” Ù†Ù„ØªÙ‚Ø· Ø¹Ù†ØµØ± Ø§Ù„Ù€ .wrap (ÙŠØ¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ùˆ Ø§Ù„Ø¬Ø¯ÙˆÙ„) ÙƒØµÙˆØ±Ø© Ø«Ù… Ù†Ø¶ÙŠÙÙ‡Ø§ Ø¥Ù„Ù‰ PDF
  async function downloadPDF() {
    if (extractedData.length === 0) return alert('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!');

    const el = document.querySelector('.wrap');
    // Ø²ÙŠØ§Ø¯Ø© scale Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¬ÙˆØ¯Ø©
    const canvas = await html2canvas(el, { scale: 2, useCORS: true, backgroundColor: null });
    const imgData = canvas.toDataURL('image/png');

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p','pt','a4');
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();

    const imgWidth = pdfWidth;
    const imgHeight = (canvas.height * imgWidth) / canvas.width;

    let heightLeft = imgHeight;
    let position = 0;

    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pdfHeight;

    while (heightLeft > 0) {
      position -= pdfHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pdfHeight;
    }

    pdf.save('courses.pdf');
  }

  // Utility: escapeHtml (to render raw strings safely)
  function escapeHtml(s) {
    if (!s) return '';
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  // Buttons wiring
  document.getElementById('btnExtract').addEventListener('click', () => {
    try { extractCourses(); }
    catch (e) { console.error(e); alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬Ø› ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù†Øµ Ø£Ùˆ Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ø«Ø§Ù„ Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ØªØ³ØªØ®Ø¯Ù…Ù‡.'); }
  });
  document.getElementById('btnMakeTable').addEventListener('click', () => {
    try { generateSchedule(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„'); }
  });
  document.getElementById('btnTXT').addEventListener('click', () => {
    try { downloadTXT(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ TXT'); }
  });
  document.getElementById('btnExcel').addEventListener('click', () => {
    try { downloadExcel(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Excel'); }
  });
  document.getElementById('btnPDF').addEventListener('click', () => {
    try { downloadPDF(); }
    catch (e) { console.error(e); alert('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ PDF'); }
  });
  document.getElementById('btnClear').addEventListener('click', () => {
    document.getElementById('inputText').value = '';
    extractedData = [];
    renderCourseList();
    document.getElementById('scheduleContainer').innerHTML = '<div class="note">Ø§Ø¶ØºØ· "Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„" Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‡Ù†Ø§.</div>';
  });

  // Ø¨Ø¯Ø§ÙŠØ©: Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
  renderCourseList();

  </script>

</body>
</html>    /* Ø¬Ø¯ÙˆÙ„ */
    .schedule {
      margin-top: 25px;
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      text-align: center;
      background: #1e293b;
      border-radius: 12px;
      overflow: hidden;
    }
    th, td {
      border: 1px solid #334155;
      padding: 10px;
      font-size: 0.9rem;
    }
    th {
      background: #0ea5e9;
      color: #fff;
    }
    td { color: #e2e8f0; }
  </style>
</head>
<body>

  <h1>Ù…Ù†ØµØ© ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</h1>

  <div class="container">
    <textarea id="inputText" placeholder="ğŸ“‹ Ø§Ù„ØµÙ‚ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§..."></textarea>

    <div class="buttons">
      <button onclick="extractCourses()">ğŸ“‘ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…ÙˆØ§Ø¯</button>
      <button onclick="generateSchedule()">ğŸ“… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„</button>
      <button onclick="downloadTXT()">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ TXT</button>
      <button onclick="downloadPDF()">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ PDF</button>
      <button onclick="downloadExcel()">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ Excel</button>
    </div>

    <div class="output">
      <h2>ğŸ“Œ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´Ø¹Ø¨</h2>
      <ul id="courseList"></ul>
    </div>

    <div class="schedule" id="scheduleContainer"></div>
  </div>

<!-- Ø£Ø¶Ù Ø§Ù„Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù€ autoTable -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

<script>
  async function downloadPDF() {
    if (extractedData.length === 0) return alert("âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª!");

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({
      orientation: "portrait",
      unit: "pt",
      format: "a4"
    });

    // ØªØ­Ù…ÙŠÙ„ Ø®Ø· ÙƒØ§ÙŠØ±Ùˆ ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ù„Ù„Ù€ jsPDF
    const fontUrl = "https://cdn.jsdelivr.net/npm/@fontsource/cairo/files/cairo-arabic-400-normal.woff";
    const font = await fetch(fontUrl).then(r => r.arrayBuffer());
    doc.addFileToVFS("Cairo.ttf", font);
    doc.addFont("Cairo.ttf", "Cairo", "normal");
    doc.setFont("Cairo");

    // Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
    doc.setFontSize(16);
    doc.text("ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´Ø¹Ø¨", 300, 40, { align: "center" });

    // ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø¬Ø¯ÙˆÙ„
    const rows = extractedData.map((d, i) => [
      i + 1,
      d.course,
      d.section,
      d.day,
      d.time,
      d.room
    ]);

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„
    doc.autoTable({
      startY: 60,
      head: [["#", "Ø§Ù„Ù…Ù‚Ø±Ø±", "Ø§Ù„Ø´Ø¹Ø¨Ø©", "Ø§Ù„ÙŠÙˆÙ…", "Ø§Ù„ÙˆÙ‚Øª", "Ø§Ù„Ù‚Ø§Ø¹Ø©"]],
      body: rows,
      styles: { font: "Cairo", fontStyle: "normal", halign: "center" },
      headStyles: { fillColor: [56, 189, 248] },
    });

    doc.save("courses.pdf");
  }
</script>
</body>
</html>
