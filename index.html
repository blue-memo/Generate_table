<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ù…Ù†ØµØ© ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ â€” Ù…ØªÙ‚Ø¯Ù…Ø©</title>

  <!-- Cairo for UI (rendered in browser) -->
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#071028; --card:#0f1b2b; --muted:#9fb0c9; --accent:#06b6d4; --danger:#ff6b6b; --ok:#34d399;
      --col-gap:14px;
    }
    *{box-sizing:border-box}
    body{font-family:"Cairo",system-ui,Arial;background:linear-gradient(180deg,#021027 0%,#08172a 100%);color:#e8f5ff;margin:0;padding:22px}
    h1{margin:0 0 8px;color:var(--accent);text-align:center}
    .wrap{max-width:1200px;margin:0 auto}
    .top{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;margin-bottom:12px}
    .note{color:var(--muted);font-size:13px}

    .grid{display:grid;grid-template-columns:1fr 420px;gap:var(--col-gap)}
    @media(max-width:1000px){.grid{grid-template-columns:1fr}}

    .card{background:var(--card);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,.6)}
    textarea{width:100%;min-height:190px;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:#071528;color:#dff3ff;resize:vertical}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{background:linear-gradient(135deg,#3b82f6,#06b6d4);border:0;padding:10px 12px;border-radius:10px;color:#022;font-weight:700;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted)}
    .small{font-size:13px;color:var(--muted)}

    /* left panel */
    .panel-list{display:flex;flex-direction:column;gap:12px}
    .list{max-height:420px;overflow:auto;padding:6px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .item{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;gap:8px;align-items:center}
    .item .meta{font-size:13px;color:var(--muted)}
    .chip{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}

    /* conflicts area */
    .conflicts{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,100,100,0.05);color:var(--danger);font-size:13px}

    /* schedule visual */
    .schedule-wrap{position:relative;height:720px;overflow:auto}
    .time-axis{position:relative;padding-left:48px;margin-bottom:8px}
    .days-row{display:grid;grid-template-columns:48px repeat(7,1fr);align-items:center}
    .time-col{width:48px;font-size:12px;color:var(--muted);text-align:center}
    .day-col{padding:6px 8px;border-left:1px solid rgba(255,255,255,0.02);font-weight:700}
    .timeline{position:relative;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);height:600px;margin-top:8px;display:grid;grid-template-columns:48px repeat(7,1fr);overflow:visible}
    .timeline .slot-times{border-right:1px solid rgba(255,255,255,0.02);padding-top:6px}
    .timeline .times-cell{height:40px;font-size:12px;color:var(--muted);text-align:center}
    .day-col-wrap{position:relative;padding:6px}
    .session{
      position:absolute;border-radius:8px;padding:6px;font-size:12px;color:#001;cursor:pointer;box-shadow:0 10px 18px rgba(2,6,23,.5);
      border:1px solid rgba(0,0,0,0.08);
    }
    .session.conflict{outline:3px solid rgba(255,107,107,0.18)}
    .badge{display:inline-block;padding:4px 8px;border-radius:8px;background:rgba(0,0,0,0.06);font-size:12px;margin-left:6px}

    /* modal */
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,6,23,0.6);z-index:999}
    .modal.open{display:flex}
    .modal .card{width:640px;max-width:95%}

    footer{margin-top:12px;text-align:center;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Ù…Ù†ØµØ© ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ â€” Ù…ØªÙ‚Ø¯Ù…Ø© (Front-End)</h1>
        <div class="note">Ø§Ù„ØµÙ‚ Ø§Ù„Ù†Øµ (Ø­ØªÙ‰ Ù„Ùˆ ÙÙŠÙ‡ Ø±Ù…ÙˆØ² ØºØ±ÙŠØ¨Ø©) â€” Ø§Ù„Ø£Ø¯Ø§Ø© ØªØµÙ„Ù‘Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ²ØŒ ØªÙ…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±ØŒ ØªÙƒØ´Ù Ø§Ù„ØªØ¶Ø§Ø±Ø¨ØŒ ÙˆØªØ¹Ø±Ø¶ Ø¬Ø¯ÙˆÙ„ ØªÙØ§Ø¹Ù„ÙŠ.</div>
      </div>
      <div class="small">Ù†Ø³Ø®Ø© Ù…ØªÙ‚Ø¯Ù…Ø© â€” Ø¨Ø¯ÙˆÙ† Back-end â€” Ø¬Ø§Ù‡Ø²Ø© Ù„ØªØ·ÙˆÙŠØ± Ù…Ø´Ø±ÙˆØ¹ ØªØ®Ø±Ø¬</div>
    </div>

    <div class="grid">
      <!-- Left: input + lists -->
      <div>
        <div class="card">
          <label class="small">ğŸ“‹ Ø§Ù„ØµÙ‚ Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… Ù‡Ù†Ø§:</label>
          <textarea id="inputText" placeholder="Ù…Ø«Ø§Ù„: Ø§Ù†Ø³Ø® Ø§Ù„Ø¨Ù„ÙˆÙƒ Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ù† Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø§Ù…Ø¹Ø©"></textarea>

          <div class="controls">
            <button id="btnExtract">ğŸ“‘ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ØªÙ‚Ø¯Ù‘Ù…</button>
            <button id="btnAutoResolve" class="ghost">ğŸ› ï¸ Ù…Ø­Ø§ÙˆÙ„Ø© Ø­Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ØªØ¶Ø§Ø±Ø¨</button>
            <button id="btnClear" class="ghost">âœ– Ù…Ø³Ø­ Ø§Ù„ÙƒÙ„</button>
            <div style="flex:1"></div>
            <button id="btnExportTXT" class="ghost">â¬‡ TXT</button>
            <button id="btnExportXLS" class="ghost">â¬‡ Excel</button>
            <button id="btnExportPDF" class="ghost">â¬‡ PDF</button>
          </div>

          <div style="display:flex;gap:10px;margin-top:12px">
            <div style="flex:1" class="card">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <strong>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´ÙØ¹Ø¨</strong>
                <span id="countItems" class="small">0</span>
              </div>
              <div class="list" id="courseList"></div>
            </div>

            <div style="width:240px" class="card">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <strong>Ø§Ù„ØªØ¹Ø§Ø±Ø¶Ø§Øª</strong>
                <span id="countConflicts" class="small">0</span>
              </div>
              <div id="conflictsList" class="list small">Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ¹Ø§Ø±Ø¶Ø§Øª Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†.</div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <strong>ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø³Ø±ÙŠØ¹Ø©</strong>
          <ul class="small" style="margin-top:8px;line-height:1.6">
            <li>1) Ø§Ù„ØµÙ‚ Ø§Ù„Ø¨Ù„ÙˆÙƒ ÙƒØ§Ù…Ù„Ø§Ù‹ Ø£Ùˆ Ø³Ø·Ø±-Ø³Ø·Ø±.</li>
            <li>2) Ø§Ø¶ØºØ· "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ØªÙ‚Ø¯Ù‘Ù…".</li>
            <li>3) Ø³ÙŠØ¸Ù‡Ø± Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„Ø£Ø³ÙÙ„ â€” Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø£ÙŠ Ø¬Ù„Ø³Ø© Ù„ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§ Ø£Ùˆ Ø­Ù„ Ø§Ù„ØªØ¹Ø§Ø±Ø¶.</li>
            <li>4) Ø§Ø³ØªØ®Ø¯Ù… "Ù…Ø­Ø§ÙˆÙ„Ø© Ø­Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ" Ù„Ø¥Ø²Ø§Ù„Ø© Ø£Ùˆ ØªØ¹Ù„ÙŠÙ… Ø¨Ø¹Ø¶ Ø§Ù„ØªØ¹Ø§Ø±Ø¶Ø§Øª (Ø§Ù‚ØªØ±Ø§Ø­ Ø¨Ø³ÙŠØ·).</li>
          </ul>
        </div>
      </div>

      <!-- Right: schedule -->
      <div>
        <div class="card">
          <strong>Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¬Ø¯ÙˆÙ„ â€” Ø¹Ø±Ø¶ Ø²Ù…Ù†ÙŠ</strong>
          <div id="scheduleArea" style="margin-top:8px">
            <div class="schedule-wrap card" id="scheduleWrap" style="padding:10px">
              <!-- dynamic content -->
              <div class="note small">Ø§Ø¶ØºØ· "Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„" Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø²Ù…Ù†ÙŠ (Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ù„Ù„Ø£ÙŠØ§Ù… ÙˆØ§Ù„Ø´Ø±Ø§Ø¦Ø­ Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø­Ø³Ø¨ Ø£ÙˆÙ‚Ø§ØªÙƒ).</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer>ØµÙ†Ø§Ø¹Ø©: ÙˆØ§Ø¬Ù‡Ø© Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ â€” Ø£Ø¶Ù Ù…ÙŠÙ‘Ø²Ø§Øª Backend Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª Ø­ÙØ¸/Ù…Ø²Ø§Ù…Ù†Ø©.</footer>
  </div>

  <!-- modal edit -->
  <div id="modal" class="modal" role="dialog" aria-hidden="true">
    <div class="card">
      <h3 id="modalTitle">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¬Ù„Ø³Ø©</h3>
      <div style="margin-top:8px">
        <label class="small">Ø§Ù„Ù…Ù‚Ø±Ø±</label>
        <input id="m_course" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081827;color:#e8f5ff">
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <div style="flex:1">
          <label class="small">Ø§Ù„Ø´Ø¹Ø¨Ø©</label>
          <input id="m_section" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081827;color:#e8f5ff">
        </div>
        <div style="flex:1">
          <label class="small">Ø§Ù„Ù‚Ø§Ø¹Ø©</label>
          <input id="m_room" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081827;color:#e8f5ff">
        </div>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <div style="flex:1">
          <label class="small">Ø§Ù„ÙŠÙˆÙ…</label>
          <input id="m_day" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081827;color:#e8f5ff">
        </div>
        <div style="flex:1">
          <label class="small">Ø§Ù„ÙˆÙ‚Øª (Ù…Ø«Ø§Ù„ 09:00-11:30)</label>
          <input id="m_time" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#081827;color:#e8f5ff">
        </div>
      </div>

      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="m_save">âœ” Ø­ÙØ¸</button>
        <button id="m_delete" class="ghost">ğŸ—‘ Ø­Ø°Ù</button>
        <button id="m_close" class="ghost">Ø¥ØºÙ„Ø§Ù‚</button>
      </div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <script>
  /*************************************************************************
   * Ù…ØªÙ‚Ø¯Ù‘Ù…: Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ØªØ±Ù…ÙŠØ²ØŒ ØªØ­Ù„ÙŠÙ„ Ù…Ø±Ù†ØŒ Ù…Ù†Ø¹ ØªÙƒØ±Ø§Ø±Ø§ØªØŒ ÙƒØ´Ù ØªØ¶Ø§Ø±Ø¨ (Ø²Ù…Ù†/Ù‚Ø§Ø¹Ø©/Ù…Ø¯Ø±Ù‘Ø³),
   * ÙˆØ§Ø¬Ù‡Ø© ØªÙØ§Ø¹Ù„ÙŠØ©: ØªØ¹Ø¯ÙŠÙ„ Ø¬Ù„Ø³Ø©ØŒ Ø­Ø°ÙØŒ ØªØ¹Ù„ÙŠÙ… ÙƒÙ…Ø­Ù„ÙˆÙ„ØŒ ØªØµØ¯ÙŠØ± TXT/Excel/PDF.
   *
   * Ù…Ù„Ø§Ø­Ø¸Ø§Øª: Ù‡Ø°Ø§ ÙƒÙˆØ¯ Ø¬Ø§Ù‡Ø² Ù„Ø¨Ø¯Ø¡ Ù…Ø´Ø±ÙˆØ¹ ØªØ®Ø±Ø¬ front-endØ› ÙŠÙ…ÙƒÙ† ØªÙˆØ³ÙŠØ¹Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹.
   *************************************************************************/

  // ========================= helpers ===========================
  const DAY_MAP = {
    'Ø³Ø¨Øª':'Ø§Ù„Ø³Ø¨Øª','Ø§Ù„Ø³Ø¨':'Ø§Ù„Ø³Ø¨Øª','Ø§Ù„Ø³Ø¨Øª':'Ø§Ù„Ø³Ø¨Øª',
    'Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø£Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø§Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø£Ø­Ø¯':'Ø§Ù„Ø£Ø­Ø¯',
    'Ø«Ù†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ø«Ù†ÙŠÙ†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ù„Ø§Ø«Ù†ÙŠÙ†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø«Ù†':'Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†',
    'Ø«Ù„':'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡':'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡',
    'Ø±Ø¨Ø¹':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡':'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡',
    'Ø®Ù…ÙŠØ³':'Ø§Ù„Ø®Ù…ÙŠØ³','Ø§Ù„Ø®Ù…ÙŠØ³':'Ø§Ù„Ø®Ù…ÙŠØ³',
    'Ø¬Ù…Ø¹Ø©':'Ø§Ù„Ø¬Ù…Ø¹Ø©','Ø§Ù„Ø¬Ù…Ø¹Ø©':'Ø§Ù„Ø¬Ù…Ø¹Ø©'
  };

  function fixEncoding(str){
    if(!str || typeof str!=='string') return str;
    try{
      const conv = decodeURIComponent(escape(str));
      // use conv only if it yields Arabic chars and original didn't
      const origHasArabic = /[\u0600-\u06FF]/.test(str);
      const convHasArabic = /[\u0600-\u06FF]/.test(conv);
      return (convHasArabic && !origHasArabic) ? conv : str;
    }catch(e){ return str; }
  }

  function normalizeSpaces(s){ return s.replace(/\u00A0/g,' ').replace(/\t+/g,' ').replace(/\s+/g,' ').trim(); }

  function parseTimeRange(text){
    if(!text) return null;
    const t = text.replace(/\s/g,'');
    // patterns: 09:00**11:30 or 09:00** 11:30 or 9:00-11:30
    let m = t.match(/(\d{1,2}:\d{2})\*{2}(\d{1,2}:\d{2})/);
    if(!m) m = t.match(/(\d{1,2}:\d{2})[-â€“to]{1,3}(\d{1,2}:\d{2})/i);
    if(!m) return null;
    const start = m[1], end = m[2];
    const toMinutes = s=>{ const [hh,mm]=s.split(':').map(x=>parseInt(x,10)); return hh*60+mm; };
    return { start, end, startMin: toMinutes(start), endMin: toMinutes(end) };
  }

  function normalizeDayToken(tok){
    if(!tok) return '';
    tok = tok.replace(/[^Ø¡-ÙŠA-Za-z0-9]/g,'').toLowerCase();
    return DAY_MAP[tok] || tok;
  }

  function colorHash(str){
    let h=0; for(let i=0;i<str.length;i++){ h = (h<<5)-h + str.charCodeAt(i); h |= 0; }
    const r = (h>>16)&0xFF, g=(h>>8)&0xFF, b=h&0xFF;
    return `rgba(${(r+80)%200},${(g+80)%200},${(b+80)%200},0.95)`;
  }

  // ========================= parsing ===========================
  // return array of session objects: {id, course, code, section, days:[], startMin, endMin, start, end, room, teacher, raw}
  function parseInput(rawText){
    const fixed = fixEncoding(rawText || '');
    const linesRaw = fixed.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const joined = linesRaw.join('\n');

    const sessions = [];
    let idCounter = 1;

    // If block-structured (contains "Ø§Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ù‚" or "Ø±Ù…Ø² Ø§Ù„Ù…Ø³Ø§Ù‚")
    if(/Ø§Ø³Ù…\s*Ø§Ù„Ù…Ø³Ø§Ù‚|Ø±Ù…Ø²\s*Ø§Ù„Ù…Ø³Ø§Ù‚|Ø±Ù‚Ù…\s*Ø§Ù„Ø³Ø·Ø±/i.test(joined)){
      // split blocks by "Ø±Ù‚Ù… Ø§Ù„Ø³Ø·Ø±" or empty line
      const blocks = joined.split(/\r?\n(?=Ø±Ù‚Ù…\s*Ø§Ù„Ø³Ø·Ø±:|Ø±Ù…Ø²\s*Ø§Ù„Ù…Ø³Ø§Ù‚:|Ø§Ø³Ù…\s*Ø§Ù„Ù…Ø³Ø§Ù‚:)/i);
      for(const b of blocks){
        const bl = b.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
        // find course name / code
        let courseName = '';
        let code = '';
        for(const l of bl){
          if(/Ø§Ø³Ù…\s*Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(l)) courseName = l.split(':').slice(1).join(':').trim();
          if(/Ø±Ù…Ø²\s*Ø§Ù„Ù…Ø³Ø§Ù‚/i.test(l)) code = l.split(':').slice(1).join(':').trim();
        }
        // rows: those starting with digit (1,2,..) likely session rows
        for(const l of bl){
          if(/^\d+\s+/.test(l) || /^\d+\t+/.test(l)){
            // split by tabs (most reliable)
            const parts = l.split(/\t+/).map(p=>p.trim()).filter(Boolean);
            // typical parts from sample:
            // [index, day, time, room, days2, time2, room2, seats, cap, registered, teacher, status, type, place]
            // We'll process first session per line; if second day/time present (col 4-6), we add another session from same line.

            // helper to attempt parse a set of columns as session
            const getSessionFromParts = (arr, startIndex=1) => {
              // arr[startIndex] => day, [startIndex+1] => time, [startIndex+2] => room
              const dayRaw = arr[startIndex] || '';
              const timeRaw = arr[startIndex+1] || '';
              const room = arr[startIndex+2] || '';
              // teacher often at index ~10
              const teacher = arr[10] || arr.slice(7,11).find(x=>/[\u0600-\u06FF]/.test(x)) || '';
              const tRange = parseTimeRange(timeRaw);
              const days = (dayRaw||'').split(/\s+/).map(normalizeDayToken).filter(Boolean);
              if(!tRange) return null;
              return {
                id: idCounter++,
                course: courseName || (parts[1]||''),
                code: code || '',
                section: '', // section not in these rows usually
                days,
                start: tRange.start,
                end: tRange.end,
                startMin: tRange.startMin,
                endMin: tRange.endMin,
                room: room || '',
                teacher: teacher || '',
                raw: l
              };
            };

            // if parts length small, try parse the entire line as single description
            if(parts.length < 4){
              // fallback parsing e.g. "ØªØ´Ø±ÙŠØ­ Ø¨ÙŠØ·Ø±ÙŠ (2) - Ø´Ø¹Ø¨Ø© 1 (Ø«Ù„ 9:00**10:00)"
              const parsed = parseFreeLine(l);
              if(parsed) sessions.push(parsed);
            } else {
              // try primary session
              const s1 = getSessionFromParts(parts,1);
              if(s1) sessions.push(s1);
              // try secondary session if columns indicate days2/time2/room2 (positions 4-6)
              if(parts.length >= 7){
                const s2 = getSessionFromParts(parts,4);
                if(s2) sessions.push(s2);
              }
            }
          } else {
            // not starting with number, try free-line parse
            const parsed = parseFreeLine(l, courseName);
            if(parsed) sessions.push(parsed);
          }
        }
      }
    } else {
      // line-by-line parsing: each line describes a session
      for(const l of linesRaw){
        const parsed = parseFreeLine(l);
        if(parsed) sessions.push(parsed);
      }
    }

    // normalize sessions: expand multiday entries into one-per-day for conflict checking and uniqueness
    const expanded = [];
    for(const s of sessions){
      const days = s.days && s.days.length ? s.days : ['ØºÙŠØ± Ù…Ø­Ø¯Ø¯'];
      for(const d of days){
        expanded.push(Object.assign({}, s, { days:[d] }));
      }
    }

    // deduplicate: unique key course|section|day|start|end|room
    const seen = new Set();
    const unique = [];
    for(const s of expanded){
      const key = `${s.course||''}|${s.section||''}|${s.days[0]||''}|${s.startMin||''}|${s.endMin||''}|${s.room||''}`;
      if(seen.has(key)) continue;
      seen.add(key);
      unique.push(s);
    }

    // finally sort by day then startMin
    unique.sort((a,b)=>{
      const dayOrder = ['Ø§Ù„Ø³Ø¨Øª','Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø®Ù…ÙŠØ³','Ø§Ù„Ø¬Ù…Ø¹Ø©','ØºÙŠØ± Ù…Ø­Ø¯Ø¯'];
      const ia = dayOrder.indexOf(a.days[0]) === -1 ? 999 : dayOrder.indexOf(a.days[0]);
      const ib = dayOrder.indexOf(b.days[0]) === -1 ? 999 : dayOrder.indexOf(b.days[0]);
      if(ia!==ib) return ia-ib;
      return (a.startMin||0) - (b.startMin||0);
    });

    return unique;
  }

  // parse free-form single-line e.g. "ØªØ´Ø±ÙŠØ­ Ø¨ÙŠØ·Ø±ÙŠ (2) - Ø´Ø¹Ø¨Ø© 1 (Ø«Ù„ 9:00**10:00)"
  function parseFreeLine(line, forcedCourseName){
    const L = normalizeSpaces(line);
    // check for pattern: Course - Ø´Ø¹Ø¨Ø© X (day time)
    // split by dash first
    let coursePart = L, rest = '';
    const dashIdx = L.search(/[-â€“â€”]/);
    if(dashIdx !== -1){
      coursePart = L.slice(0,dashIdx).trim();
      rest = L.slice(dashIdx+1).trim();
    }

    // get course
    let course = forcedCourseName || coursePart;
    // find section
    let section = '';
    const secMatch = L.match(/\bØ´Ø¹Ø¨Ø©\s*([^\s()]+)/i) || L.match(/\bSection\s*([A-Za-z0-9\-]+)/i);
    if(secMatch) section = secMatch[1].trim();

    // find parentheses for day/time
    const paren = L.match(/\(([^)]+)\)/g);
    let dayTokens = [], timeRange = null, room = '', teacher = '';
    if(paren){
      // pick the parenthesis that contains time digits
      for(const p of paren){
        if(/\d{1,2}:\d{2}/.test(p)){
          // extract day token and time inside
          const inner = p.replace(/\(|\)/g,'').trim();
          // try find time
          const tr = parseTimeRange(inner);
          if(tr) timeRange = tr;
          // day token
          const dayTok = inner.match(/\b(Ø³Ø¨Øª|Ø§Ù„Ø³Ø¨Øª|Ø­Ø¯|Ø£Ø­Ø¯|Ø§Ù„Ø§Ø­Ø¯|Ø«Ù†|Ø§Ø«Ù†ÙŠÙ†|Ø§Ù„Ø§Ø«Ù†ÙŠÙ†|Ø«Ù„|Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡|Ø±Ø¨Ø¹|Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡|Ø®Ù…ÙŠØ³|Ø§Ù„Ø®Ù…ÙŠØ³|Ø¬Ù…Ø¹Ø©|Ø§Ù„Ø¬Ù…Ø¹Ø©)\b/);
          if(dayTok) dayTokens = inner.split(/\s+/).map(normalizeDayToken).filter(Boolean);
        } else {
          // might be course suffix or room
          if(/\b(LAB|NB|SF|SG|U)\b/i.test(p)) room = p.replace(/\(|\)/g,'').trim();
        }
      }
    }

    // fallback: try to find day/time in rest
    if(!timeRange){
      const tmatch = rest.match(/(\d{1,2}:\d{2})\s*\*{2}\s*(\d{1,2}:\d{2})/) ||
                     rest.match(/(\d{1,2}:\d{2})\s*[-â€“to]{1,3}\s*(\d{1,2}:\d{2})/i);
      if(tmatch) {
        timeRange = { start: tmatch[1], end: tmatch[2], startMin: parseInt(tmatch[1].split(':')[0])*60 + parseInt(tmatch[1].split(':')[1]), endMin: parseInt(tmatch[2].split(':')[0])*60 + parseInt(tmatch[2].split(':')[1]) };
      }
      const dmatch = rest.match(/\b(Ø³Ø¨Øª|Ø§Ù„Ø³Ø¨Øª|Ø­Ø¯|Ø£Ø­Ø¯|Ø§Ù„Ø§Ø­Ø¯|Ø«Ù†|Ø§Ø«Ù†ÙŠÙ†|Ø§Ù„Ø§Ø«Ù†ÙŠÙ†|Ø«Ù„|Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡|Ø±Ø¨Ø¹|Ø§Ù„Ø§Ø±Ø¨Ø¹Ø§Ø¡|Ø®Ù…ÙŠØ³|Ø§Ù„Ø®Ù…ÙŠØ³|Ø¬Ù…Ø¹Ø©|Ø§Ù„Ø¬Ù…Ø¹Ø©)\b/);
      if(dmatch) dayTokens = rest.split(/\s+/).map(normalizeDayToken).filter(Boolean);
      const roomMatch = rest.match(/\b(NB\d+|SF\d+|SG\d+|LAB|U|[A-Z]{2,}\d{0,})\b/i);
      if(roomMatch) room = roomMatch[0];
    }

    if(!timeRange) return null;
    if(dayTokens.length === 0) dayTokens = ['ØºÙŠØ± Ù…Ø­Ø¯Ø¯'];

    // return one object (days array) â€” caller will expand
    return {
      id: Math.floor(Math.random()*1e9),
      course: course || '',
      code: '',
      section: section || '',
      days: dayTokens,
      start: timeRange.start,
      end: timeRange.end,
      startMin: timeRange.startMin,
      endMin: timeRange.endMin,
      room: room || '',
      teacher: teacher || '',
      raw: line
    };
  }

  // ========================= conflict detection ===========================
  // returns { sessions: [...], conflicts: [...] }
  function detectConflicts(sessions){
    // build per-day arrays
    const perDay = {};
    sessions.forEach(s=>{
      const day = s.days[0] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
      if(!perDay[day]) perDay[day]=[];
      perDay[day].push(s);
    });

    const conflicts = [];
    // helper overlap
    const overlap = (a,b)=> (a.startMin < b.endMin) && (b.startMin < a.endMin);

    // check per day
    Object.keys(perDay).forEach(day=>{
      const arr = perDay[day].slice().sort((a,b)=> (a.startMin||0) - (b.startMin||0));
      for(let i=0;i<arr.length;i++){
        for(let j=i+1;j<arr.length;j++){
          const a = arr[i], b = arr[j];
          if(!a.startMin || !a.endMin || !b.startMin || !b.endMin) continue;
          if(overlap(a,b)){
            // record conflict type(s)
            const types = [];
            if(a.room && b.room && a.room.toLowerCase()===b.room.toLowerCase()) types.push('Ù‚Ø§Ø¹Ø©');
            if(a.teacher && b.teacher && a.teacher === b.teacher) types.push('Ù…Ø¯Ø±Ø³');
            types.push('Ø²Ù…Ù†ÙŠ');
            const conflict = { aId: a.id, bId: b.id, day, types:[...new Set(types)], a, b };
            conflicts.push(conflict);
            // mark sessions with conflict flag
            a._conflict = true; b._conflict = true;
          }
        }
      }
    });

    return { sessions, conflicts };
  }

  // ========================= rendering ===========================
  let CURRENT_SESSIONS = []; // current parsed sessions (one per day)
  function renderList(sessions, conflicts){
    const wrap = document.getElementById('courseList');
    wrap.innerHTML = '';
    if(sessions.length===0){ wrap.innerHTML = '<div class="small">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª Ù…Ø³ØªØ®Ø±Ø¬Ø© Ø¨Ø¹Ø¯.</div>'; document.getElementById('countItems').textContent='0'; return; }
    sessions.forEach(s=>{
      const div = document.createElement('div');
      div.className='item';
      const left = document.createElement('div'); left.style.flex='1';
      left.innerHTML = `<div><strong>${escapeHtml(s.course || 'â€”')}</strong> ${s.section ? '<span class="chip">Ø´: '+escapeHtml(s.section)+'</span>':''}</div>
                        <div class="meta">${s.days[0] || '-'} | ${s.start || '-'} - ${s.end || '-'} ${s.room?('| ' + escapeHtml(s.room)) : ''}</div>`;
      const right = document.createElement('div');
      right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
      const btn = document.createElement('button'); btn.textContent='ØªØ¹Ø¯ÙŠÙ„'; btn.style.padding='6px 8px'; btn.addEventListener('click',()=> openEditModal(s.id));
      right.appendChild(btn);

      if(s._conflict){
        const cspan = document.createElement('div'); cspan.className='chip'; cspan.style.background='rgba(255,107,107,0.12)'; cspan.textContent='ØªØ¹Ø§Ø±Ø¶'; right.appendChild(cspan);
      }

      div.appendChild(left); div.appendChild(right);
      wrap.appendChild(div);
    });
    document.getElementById('countItems').textContent = sessions.length;
    renderConflictsList(conflicts);
    renderScheduleVisual(sessions);
  }

  function renderConflictsList(conflicts){
    const el = document.getElementById('conflictsList');
    if(!conflicts || conflicts.length===0){ el.innerHTML = '<div class="small">Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ¹Ø§Ø±Ø¶Ø§Øª.</div>'; document.getElementById('countConflicts').textContent='0'; return; }
    el.innerHTML = '';
    conflicts.forEach((c,idx)=>{
      const d = document.createElement('div'); d.style.padding='8px'; d.style.borderBottom='1px solid rgba(255,255,255,0.03)';
      d.innerHTML = `<div><strong>ØªØ¹Ø§Ø±Ø¶ ${idx+1}</strong> â€” ÙŠÙˆÙ… ${c.day} | <span class="small">${c.types.join(', ')}</span></div>
                     <div class="small" style="margin-top:6px">${escapeHtml(c.a.course)} (${c.a.start}-${c.a.end}) â‡„ ${escapeHtml(c.b.course)} (${c.b.start}-${c.b.end})</div>`;
      el.appendChild(d);
    });
    document.getElementById('countConflicts').textContent = conflicts.length;
  }

  // schedule visual: compute min/max time from data and render sessions positioned
  function renderScheduleVisual(sessions){
    CURRENT_SESSIONS = sessions;
    const wrap = document.getElementById('scheduleWrap');
    wrap.innerHTML = '';

    if(sessions.length===0){ wrap.innerHTML = '<div class="note small">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„.</div>'; return; }

    // compute min and max minutes
    let minMin = 24*60, maxMin = 0;
    sessions.forEach(s=>{
      if(s.startMin) minMin = Math.min(minMin, s.startMin);
      if(s.endMin) maxMin = Math.max(maxMin, s.endMin);
    });
    if(minMin===24*60){ minMin = 8*60; maxMin = 17*60; } // defaults
    // pad
    minMin = Math.max(0, minMin - 60);
    maxMin = Math.min(24*60, maxMin + 60);

    const dayOrder = ['Ø§Ù„Ø³Ø¨Øª','Ø§Ù„Ø£Ø­Ø¯','Ø§Ù„Ø¥Ø«Ù†ÙŠÙ†','Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡','Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡','Ø§Ù„Ø®Ù…ÙŠØ³','Ø§Ù„Ø¬Ù…Ø¹Ø©'];
    // header days row
    const header = document.createElement('div'); header.className='time-axis';
    const daysRow = document.createElement('div'); daysRow.className='days-row';
    daysRow.innerHTML = `<div class="time-col"></div>${dayOrder.map(d=>`<div class="day-col">${d}</div>`).join('')}`;
    header.appendChild(daysRow);
    wrap.appendChild(header);

    // timeline grid
    const timeline = document.createElement('div'); timeline.className='timeline';
    // left column: times
    const timesCol = document.createElement('div'); timesCol.className='slot-times';
    // create rows by 30-minute steps
    const step = 30;
    const totalSteps = Math.ceil((maxMin - minMin)/step);
    for(let i=0;i<totalSteps;i++){
      const cell = document.createElement('div'); cell.className='times-cell';
      const m = minMin + i*step;
      const hh = String(Math.floor(m/60)).padStart(2,'0'), mm = String(m%60).padStart(2,'0');
      cell.textContent = `${hh}:${mm}`;
      cell.style.height = `${(step/60)*60}px`; // 30min -> 30px
      timesCol.appendChild(cell);
    }
    timeline.appendChild(timesCol);

    // day columns container
    const dayCols = [];
    for(let d=0; d<7; d++){
      const col = document.createElement('div'); col.className='day-col-wrap'; col.style.position='relative'; col.style.minHeight = `${totalSteps * ((step/60)*60)}px`; timeline.appendChild(col); dayCols.push(col);
    }

    // px per minute
    const pxPerMin = ( (step/60)*60 ) / step; // 1 px per minute (since step 30 -> 30px)
    // for each session, place it in the appropriate day column(s)
    sessions.forEach(s=>{
      const day = s.days[0] || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
      const dayIdx = dayOrder.indexOf(day);
      if(dayIdx === -1) return; // skip if day not recognized
      if(!s.startMin || !s.endMin) return;
      const top = (s.startMin - minMin) * pxPerMin;
      const height = Math.max(28, (s.endMin - s.startMin) * pxPerMin - 2);
      const leftCol = dayCols[dayIdx];

      const el = document.createElement('div');
      el.className='session';
      el.style.top = top + 'px';
      el.style.left = '6px';
      el.style.right = '6px';
      el.style.height = height + 'px';
      el.style.background = colorHash(s.course || s.room || s.id);
      el.dataset.id = s.id;
      el.innerHTML = `<div style="font-weight:700">${escapeHtml(s.course||'â€”')}</div><div style="font-size:12px;margin-top:4px">${s.start || ''} - ${s.end || ''} ${s.room? '| '+escapeHtml(s.room):''}</div>`;
      if(s._conflict) el.classList.add('conflict');
      el.addEventListener('click', ()=> openEditModal(s.id));
      leftCol.appendChild(el);
    });

    wrap.appendChild(timeline);
  }

  // ========================= editing modal ===========================
  const modal = document.getElementById('modal');
  let modalTargetId = null;
  function openEditModal(id){
    const s = CURRENT_SESSIONS.find(x=>x.id===id);
    if(!s) return;
    modalTargetId = id;
    document.getElementById('modalTitle').textContent = `ØªØ¹Ø¯ÙŠÙ„: ${s.course}`;
    document.getElementById('m_course').value = s.course || '';
    document.getElementById('m_section').value = s.section || '';
    document.getElementById('m_room').value = s.room || '';
    document.getElementById('m_day').value = s.days[0] || '';
    document.getElementById('m_time').value = `${s.start || ''}-${s.end || ''}`;
    modal.classList.add('open');
  }
  document.getElementById('m_close').addEventListener('click', ()=> modal.classList.remove('open'));
  document.getElementById('m_delete').addEventListener('click', ()=>{
    if(!modalTargetId) return;
    CURRENT_SESSIONS = CURRENT_SESSIONS.filter(x=>x.id!==modalTargetId);
    modalTargetId = null;
    modal.classList.remove('open');
    recomputeAndRender();
  });
  document.getElementById('m_save').addEventListener('click', ()=>{
    if(!modalTargetId) return;
    const s = CURRENT_SESSIONS.find(x=>x.id===modalTargetId);
    if(!s) return;
    s.course = document.getElementById('m_course').value.trim();
    s.section = document.getElementById('m_section').value.trim();
    s.room = document.getElementById('m_room').value.trim();
    s.days = [ normalizeDayToken(document.getElementById('m_day').value.trim()) || s.days[0] ];
    const time = document.getElementById('m_time').value.trim();
    const tt = time.match(/(\d{1,2}:\d{2})\s*[-â€“]\s*(\d{1,2}:\d{2})/);
    if(tt){ s.start = tt[1]; s.end = tt[2]; s.startMin = parseInt(tt[1].split(':')[0])*60 + parseInt(tt[1].split(':')[1]); s.endMin = parseInt(tt[2].split(':')[0])*60 + parseInt(tt[2].split(':')[1]); }
    modal.classList.remove('open');
    recomputeAndRender();
  });

  // ========================= recompute & export ===========================
  function recomputeAndRender(){
    // detect conflicts
    const { sessions, conflicts } = detectConflicts(CURRENT_SESSIONS);
    renderList(sessions, conflicts);
  }

  // Export TXT, includes conflict notes
  function exportTXT(){
    if(CURRENT_SESSIONS.length===0) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±');
    const lines = [];
    lines.push('Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ø´ÙØ¹Ø¨');
    lines.push('');
    CURRENT_SESSIONS.forEach((s,i)=>{
      const flag = s._conflict ? ' [âš  ØªØ¹Ø§Ø±Ø¶]' : '';
      lines.push(`${i+1}. ${s.course} ${s.section ? '- Ø´Ø¹Ø¨Ø© '+s.section : ''} | ${s.days[0] || '-'} | ${s.start || '-'} - ${s.end || '-'} | ${s.room || '-'}${flag}`);
    });
    const blob = new Blob(['\uFEFF' + lines.join('\n')], { type:'text/plain;charset=utf-8' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='timetable.txt'; a.click();
  }

  // Export Excel
  function exportXLS(){
    if(CURRENT_SESSIONS.length===0) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±');
    const aoa = [['Ø§Ù„Ù…Ù‚Ø±Ø±','Ø§Ù„Ø´Ø¹Ø¨Ø©','Ø§Ù„ÙŠÙˆÙ…','Ù…Ù†','Ø¥Ù„Ù‰','Ø§Ù„Ù‚Ø§Ø¹Ø©','ØªØ¹Ø§Ø±Ø¶']];
    CURRENT_SESSIONS.forEach(s=>{
      aoa.push([s.course || '', s.section || '', s.days[0] || '', s.start || '', s.end || '', s.room || '', s._conflict ? 'Ù†Ø¹Ù…' : '']);
    });
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, 'Ø§Ù„Ø¬Ø¯ÙˆÙ„');
    XLSX.writeFile(wb, 'timetable.xlsx');
  }

  // Export PDF (capture scheduleWrap area)
  async function exportPDF(){
    if(CURRENT_SESSIONS.length===0) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±');
    const el = document.getElementById('scheduleWrap');
    const canvas = await html2canvas(el, { scale: 2, useCORS: true, backgroundColor: '#071028' });
    const img = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p','pt','a4');
    const pdfW = pdf.internal.pageSize.getWidth();
    const pdfH = pdf.internal.pageSize.getHeight();

    const imgW = pdfW;
    const imgH = canvas.height * imgW / canvas.width;

    let position = 0;
    pdf.addImage(img,'PNG',0,position,imgW,imgH);
    let heightLeft = imgH - pdfH;
    while(heightLeft > 0){
      position -= pdfH;
      pdf.addPage();
      pdf.addImage(img,'PNG',0,position,imgW,imgH);
      heightLeft -= pdfH;
    }
    pdf.save('timetable.pdf');
  }

  // autoResolve simple strategy: if two sessions conflict, prefer the one with more registered seats? (we don't have seats reliably)
  // For now: mark conflicts that share same course as resolved (assume duplicates), else prompt user to edit â€” we'll just flag duplicates removal
  function autoResolve(){
    if(CURRENT_SESSIONS.length===0) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª');
    // remove exact duplicates already handled; here remove conflicts where course names equal (duplicate entries)
    let removed = 0;
    const toRemove = new Set();
    const { conflicts } = detectConflicts(CURRENT_SESSIONS);
    conflicts.forEach(c=>{
      if(c.a.course && c.b.course && c.a.course === c.b.course){
        // remove the one with same course but later start time (arbitrary)
        const removeId = ( (c.a.startMin||0) > (c.b.startMin||0) ) ? c.a.id : c.b.id;
        toRemove.add(removeId);
      }
    });
    if(toRemove.size>0){
      CURRENT_SESSIONS = CURRENT_SESSIONS.filter(s=>!toRemove.has(s.id));
      removed = toRemove.size;
      recomputeAndRender();
    }
    alert(`Ù…Ø­Ø§ÙˆÙ„Ø© Ø­Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø§Ù†ØªÙ‡Øª â€” Ø£Ø²Ù„Øª ${removed} Ø­Ø¯Ø«Ù‹Ø§ Ù…ÙƒØ±Ø±Ù‹Ø§/Ù…ØªØ¶Ø§Ø±Ø¨Ù‹Ø§ (Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø¨Ø³ÙŠØ·Ø©).`);
  }

  // ========================= UI wiring ===========================
  document.getElementById('btnExtract').addEventListener('click', ()=>{
    try{
      const raw = document.getElementById('inputText').value;
      const parsed = parseInput(raw);
      CURRENT_SESSIONS = parsed;
      const { conflicts } = detectConflicts(CURRENT_SESSIONS);
      renderList(CURRENT_SESSIONS, conflicts);
      if(parsed.length===0) alert('Ù„Ù… Ø£Ø³ØªØ®Ø±Ø¬ Ø£ÙŠ Ø¬Ù„Ø³Ø§Øª â€” ØªØ£ÙƒØ¯ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ Ø£Ùˆ Ø£Ø±Ø³Ù„ Ø³Ø·Ø±Ù‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ Ù„Ø£Ø­Ù‚Ù‘Ù‚ Ù…Ù†Ù‡.');
      else alert(`ØªÙ… Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬: ${parsed.length} Ø¬Ù„Ø³Ø©. Ø¹Ø¯Ø¯ Ø§Ù„ØªØ¹Ø§Ø±Ø¶Ø§Øª: ${conflicts.length}`);
    }catch(e){
      console.error(e);
      alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ â€” Ø§ÙØ­Øµ Ø§Ù„Ù†Øµ Ø£Ùˆ Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ø«Ø§Ù„ Ø§Ù„Ø³Ø·ÙˆØ± Ù„Ø£Ø¶Ø¨Ø· Ø§Ù„Ø¨Ø§Ø±Ø³ÙØ±.');
    }
  });

  document.getElementById('btnClear').addEventListener('click', ()=>{
    if(!confirm('Ù‡Ù„ ØªØ±ÙŠØ¯ Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ')) return;
    document.getElementById('inputText').value='';
    CURRENT_SESSIONS=[];
    renderList([],[]);
    document.getElementById('scheduleWrap').innerHTML = '<div class="note small">Ø§Ø¶ØºØ· "Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ØªÙ‚Ø¯Ù‘Ù…" Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‡Ù†Ø§.</div>';
  });

  document.getElementById('btnExportTXT').addEventListener('click', exportTXT);
  document.getElementById('btnExportXLS').addEventListener('click', exportXLS);
  document.getElementById('btnExportPDF').addEventListener('click', exportPDF);
  document.getElementById('btnAutoResolve').addEventListener('click', autoResolve);

  // helper escape
  function escapeHtml(s){ if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // initial empty render
  renderList([],[]);
  </script>
</body>
        </html>
